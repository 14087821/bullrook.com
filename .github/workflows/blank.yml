# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
<!DOCTYPE html>
<html lang="es"><div class="step-item">
    <h3>Paso 3: ¬°Interact√∫a y Toma el Control!</h3>
    <p>Est√°s conectado y tienes fondos. Ahora puedes gestionar tu cartera. <strong>Verifica tus balances</strong> de $DYDX y USDC, <strong>haz staking</strong> para ganar recompensas y <strong>accede al *exchange*</strong> para empezar a operar en el mercado descentralizado.</p>
    
    <hr style="margin: 20px 0;">
    
    <h4>üìä Mi Panel de Control</h4>
    <div id="balanceDisplay" style="background-color: #eee; padding: 15px; border-radius: 5px; margin-bottom: 20px; font-family: monospace;">
        <p>Cargando balances...</p>
    </div>

    <div style="display: flex; gap: 15px;">
        <button id="goToTrade" class="cta-button" style="background-color: #1e88e5;">üìà Acceder al Exchange</button>
        <button id="goToStake" class="cta-button" style="background-color: #43a047;">üîí Hacer Staking $DYDX</button>
    </div>
</div>

<head><div class="step-item">
    <h3>Paso 2: Obt√©n Tokens $DYDX (y USDC)</h3>
    <p>Para operar en la dYdX Chain, necesitas <strong>$DYDX nativo</strong> para <em>staking</em> y <strong>USDC</strong> para comerciar. Si tienes $DYDX en Ethereum (ERC-20), debes usar el <strong>Bridge Oficial</strong>. Si no tienes, puedes comprar $DYDX o USDC en un exchange centralizado y luego enviarlos.</p>
    
    <h4>Opciones para Financiar tu Cuenta:</h4>
    <div style="display: flex; gap: 15px; margin-top: 15px;">
        <a href="https://bridge.dydx.trade/" target="_blank" style="text-decoration: none;">
            <button class="cta-button" style="background-color: #008fa3;">üåâ Usar Bridge Oficial</button>
        </a>
        
        <a href="https://help.dydx.trade/en/articles/166971-how-to-withdraw-on-dydx" target="_blank" style="text-decoration: none;">
            <button class="cta-button" style="background-color: #555;">üí∞ Comprar en un Exchange</button>
        </a>

        <a href="https://crypto-economy.com/es/dydx-amplia-los-incentivos-para-sus-afiliados-con-un-nuevo-nivel-del-50/" target="_blank" style="text-decoration: none;">
            <button class="cta-button" style="background-color: #aaa; color: #333;">üìñ Ver Gu√≠a Completa</button>
        </a>
    </div>
</div>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal DYDX Chain</title>
    <style>
        /* Estilos CSS B√ÅSICOS para la estructura */
        body { font-family: sans-serif; margin: 0; padding: 0; background-color: #f4f7f9; color: #333; }<script>
    const chainId = 'dydx-mainnet-1'; // ID de la cadena que identificamos

    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        const statusElement = document.getElementById('walletStatus');

        // 1. Verificar si Keplr est√° instalado
        if (typeof window.keplr === 'undefined') {
            statusElement.textContent = 'Estado: ¬°Instala Keplr para continuar!';
            alert('Keplr no est√° instalado. Por favor, inst√°lalo para conectarte a la dYdX Chain.');
            return;
        }

        try {
            // 2. Solicitar permiso para conectarse a la dYdX Chain
            await window.keplr.enable(chainId);
            statusElement.textContent = 'Estado: ‚úÖ Conectado con √©xito.';
            
            // 3. Obtener la direcci√≥n del usuario (opcional, pero √∫til)
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Mostrar la direcci√≥n en el estado (o en otro lugar de la p√°gina)
            statusElement.innerHTML = `Estado: ‚úÖ Conectado. Direcci√≥n: <strong>${accounts[0].address.substring(0, 10)}...</strong>`;
            
            alert('¬°Conexi√≥n exitosa a la dYdX Chain!');

        } catch (error) {
            // 4. Manejar errores de conexi√≥n
            console.error('Error al conectar la billetera:', error);
            statusElement.textContent = 'Estado: ‚ùå Fallo en la conexi√≥n. Revisa la consola o intenta de nuevo.';
            alert('Fallo en la conexi√≥n. Aseg√∫rate de que la dYdX Chain est√© aprobada en Keplr.');
        }
    });
</script>

        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        header { background-color: #000000; color: #ffffff; padding: 40px 20px; text-align: center; }
        header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .cta-button { background-color: #00bcd4; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; transition: background-color 0.3s; }
        .cta-button:hover { background-color: #008fa3; }
        .steps, .details { padding: 40px 0; }
        .step-item { background-color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .step-item h3 { color: #00bcd4; }
    </style>
</head>
<body>

    <header>
        <h1>[Nombre del Proyecto]: Accede al Futuro Financiero Descentralizado</h1>
        <h2>Comercia, Gana e Interact√∫a con el Token $DYDX y la Red dYdX Chain.</h2>
        <p>$DYDX Valor actual: ‚âà $0.25 USD</p>
        <button id="connectWalletBtn" class="cta-button">üöÄ Empezar Ahora / Conectar Billetera</button>
    </header>

    <div class="container">

        <section class="steps">
            <h2>Gu√≠a R√°pida: 3 Pasos para Empezar</h2>
            <div class="step-item">
                <h3>Paso 1: Conecta tu Billetera (Wallet)</h3>
                <p>Aseg√∫rate de tener una billetera compatible. Haz clic en el bot√≥n de arriba y aprueba la conexi√≥n. **Es tu llave de acceso, segura y privada.**</p>
                <div id="walletStatus">Estado: Desconectado</div>
            </div>
            </section>

        </div>

</body>
</html>

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
<script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script>
<script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script>
<script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script><script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script><script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script>
<script>
    // ... (El c√≥digo de conexi√≥n de la billetera del Paso 1 va aqu√≠) ...

    const chainId = 'dydx-mainnet-1'; 
    const rpcEndpoint = 'https://rpc.dydx.nodex.one:443'; // Ejemplo de endpoint RPC (debe ser un nodo v√°lido)
    
    // NOTA: Estas denominaciones DEBEN ser las exactas en la dYdX Chain. 
    // Por convenci√≥n, usaremos 'adyD' para el token nativo y un placeholder para USDC.
    const nativeDenom = 'adyD'; 
    const usdcDenom = 'ibc/0000000000000000000000000000000000000000000000000000000000000000'; // Placeholder para USDC (suele ser un hash IBC largo)

    /**
     * Funci√≥n que detecta la billetera conectada y llama a la API de la cadena
     * para obtener los balances del usuario.
     */
    async function fetchBalances(address) {
        const display = document.getElementById('balanceDisplay');
        display.innerHTML = '<p>Cargando balances...</p>';
        
        try {
            // Usamos un endpoint RPC para consultar datos (lectura)
            const response = await fetch(`${rpcEndpoint}/cosmos/bank/v1beta1/balances/${address}`);
            const data = await response.json();
            
            let dydxBalance = 0;
            let usdcBalance = 0;
            
            // 1. Procesar los balances
            if (data.balances && data.balances.length > 0) {
                data.balances.forEach(coin => {
                    // La denominaci√≥n nativa (adyD) se divide por 1,000,000,000,000,000,000 para obtener el $DYDX
                    if (coin.denom === nativeDenom) {
                        // Asumimos 18 decimales por ser un token migrado de ERC-20
                        dydxBalance = (parseFloat(coin.amount) / 1e18).toFixed(4); 
                    } 
                    // El USDC (usando un hash IBC real) suele tener 6 decimales
                    else if (coin.denom === usdcDenom) { 
                        usdcBalance = (parseFloat(coin.amount) / 1e6).toFixed(2);
                    }
                    // NOTA: Es esencial confirmar los decimales exactos (1e18 para DYDX, 1e6 para USDC).
                });
            }

            // 2. Mostrar los resultados
            display.innerHTML = `
                <p><strong>Direcci√≥n:</strong> ${address}</p>
                <p><strong>Balance $DYDX Nativo:</strong> ${dydxBalance} DYDX</p>
                <p><strong>Balance USDC:</strong> ${usdcBalance} USDC</p>
            `;

        } catch (error) {
            console.error('Error al obtener balances:', error);
            display.innerHTML = '<p style="color: red;">‚ùå Error al cargar los balances. Aseg√∫rate de que el RPC est√© activo.</p>';
        }
    }


    // --- INTEGRACI√ìN CON EL PASO 1 (CONEXI√ìN) ---

    // Modificamos el listener del bot√≥n principal para que, si est√° conectado, muestre balances
    document.getElementById('connectWalletBtn').addEventListener('click', async () => {
        // ... (todo el c√≥digo de conexi√≥n del Paso 1) ...
        
        // C√ìDIGO A√ëADIDO: Si la conexi√≥n es exitosa, llama a fetchBalances
        try {
            await window.keplr.enable(chainId);
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            
            // Llama a la nueva funci√≥n de balances
            fetchBalances(accounts[0].address); 
            // ... (el resto del c√≥digo de status del Paso 1) ...
            
        } catch (error) {
            // Manejar errores de conexi√≥n
        }
    });

</script>


<hr style="margin: 20px 0;">
<h4>üõí Enviar una Orden (Ejemplo)</h4>

<div style="padding: 15px; border: 1px solid #ccc; border-radius: 5px;">
    <label for="market">Mercado:</label>
    <select id="market" style="padding: 8px; margin-bottom: 10px;">
        <option value="BTC-USD">BTC/USD (Ejemplo)</option> 
        <option value="ETH-USD">ETH/USD (Ejemplo)</option>
    </select>
    
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <label for="side">Tipo:</label>
        <select id="side" style="padding: 8px;">
            <option value="BUY">Comprar (Largo)</option>
            <option value="SELL">Vender (Corto)</option>
        </select>
        
        <label for="size">Tama√±o:</label>
        <input type="number" id="size" placeholder="Cantidad de Base" style="padding: 8px; width: 100px;">
        
        <label for="price">Precio L√≠mite:</label>
        <input type="number" id="price" placeholder="Precio USD" style="padding: 8px; width: 100px;">
    </div>
    
    <button id="submitOrderBtn" class="cta-button" style="background-color: #1e88e5; width: 100%;">
        Enviar Orden L√≠mite
    </button>
    <p id="orderStatus" style="margin-top: 10px; font-size: 0.9em;"></p>
</div>
<script>
    // ... (El c√≥digo de conexi√≥n y balances anteriores) ...

    document.getElementById('submitOrderBtn').addEventListener('click', async () => {
        const orderStatus = document.getElementById('orderStatus');
        orderStatus.textContent = 'Procesando orden...';
        
        // 1. Obtener los par√°metros del formulario
        const market = document.getElementById('market').value;
        const side = document.getElementById('side').value; // BUY o SELL
        const size = document.getElementById('size').value;
        const price = document.getElementById('price').value;
        
        if (!size || !price) {
            orderStatus.textContent = '‚ùå Por favor, ingresa el tama√±o y el precio.';
            return;
        }

        try {
            // 2. Obtener la direcci√≥n y el firmador (signer) de Keplr
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            const userAddress = accounts[0].address;

            // 3. Crear el mensaje de orden (ESTO ES CONCEPTUAL Y DEPENDE DE LA LIBRER√çA)
            // En un proyecto real, se usar√≠a un MessageComposer espec√≠fico de dYdX.
            const msgOrder = {
                typeUrl: "/dydx.exchange.v3.MsgCreateOrder", // Tipo de mensaje espec√≠fico de dYdX
                value: {
                    sender: userAddress,
                    market: market,
                    side: side,
                    size: size,
                    price: price,
                    // Otros par√°metros como expiration, type (LIMIT/MARKET), etc.
                }
            };
            
            // 4. Enviar la transacci√≥n (requiere el objeto SigningStargateClient)
            // const client = await SigningStargateClient.connectWithSigner(rpcEndpoint, offlineSigner);
            
            // const fee = { amount: [{ denom: nativeDenom, amount: "100" }], gas: "200000" };
            
            // const txResponse = await client.signAndBroadcast(userAddress, [msgOrder], fee, "Creando orden en dYdX");

            // --- SIMULACI√ìN DEL √âXITO ---
            orderStatus.textContent = `‚úÖ Orden de ${side} ${size} ${market} a ${price} USD enviada. (Simulado)`;
            console.log('Orden simulada. En un entorno real, la respuesta de la TX ser√≠a:', 'txResponse');
            
        } catch (error) {
            console.error('Error al enviar la orden:', error);
            orderStatus.textContent = `‚ùå Fallo al enviar la orden: ${error.message}`;
        }
    });

</script><hr style="margin: 20px 0;">
<h4>üîí Delegar Tokens $DYDX (Staking)</h4>

<div style="padding: 15px; border: 1px solid #43a047; border-radius: 5px;">
    <label for="validatorList">Selecciona un Validador:</label>
    <select id="validatorList" style="padding: 8px; margin-bottom: 10px; width: 100%;">
        <option value="dydxvaloper1a...1">Validator A - [Tasa de Comisi√≥n 5%]</option> 
        <option value="dydxvaloper1b...2">Validator B - [Tasa de Comisi√≥n 10%]</option>
        <option value="dydxvaloper1c...3">Validator C - [Auto-delegado]</option>
    </select>
    
    <label for="stakeAmount">Cantidad a Delegar ($DYDX):</label>
    <input type="number" id="stakeAmount" placeholder="Ej: 1000" style="padding: 8px; width: 100%;">
    
    <button id="submitStakeBtn" class="cta-button" style="background-color: #43a047; width: 100%; margin-top: 10px;">
        Delegar $DYDX
    </button>
    <p id="stakeStatus" style="margin-top: 10px; font-size: 0.9em;"></p>
</div>
<script>
    // ... (El c√≥digo de conexi√≥n y balances anteriores) ...

    document.getElementById('submitOrderBtn').addEventListener('click', async () => {
        const orderStatus = document.getElementById('orderStatus');
        orderStatus.textContent = 'Procesando orden...';
        
        // 1. Obtener los par√°metros del formulario
        const market = document.getElementById('market').value;
        const side = document.getElementById('side').value; // BUY o SELL
        const size = document.getElementById('size').value;
        const price = document.getElementById('price').value;
        
        if (!size || !price) {
            orderStatus.textContent = '‚ùå Por favor, ingresa el tama√±o y el precio.';
            return;
        }

        try {
            // 2. Obtener la direcci√≥n y el firmador (signer) de Keplr
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            const userAddress = accounts[0].address;

            // 3. Crear el mensaje de orden (ESTO ES CONCEPTUAL Y DEPENDE DE LA LIBRER√çA)
            // En un proyecto real, se usar√≠a un MessageComposer espec√≠fico de dYdX.
            const msgOrder = {
                typeUrl: "/dydx.exchange.v3.MsgCreateOrder", // Tipo de mensaje espec√≠fico de dYdX
                value: {
                    sender: userAddress,
                    market: market,
                    side: side,
                    size: size,
                    price: price,
                    // Otros par√°metros como expiration, type (LIMIT/MARKET), etc.
                }
            };
            
            // 4. Enviar la transacci√≥n (requiere el objeto SigningStargateClient)
            // const client = await SigningStargateClient.connectWithSigner(rpcEndpoint, offlineSigner);
            
            // const fee = { amount: [{ denom: nativeDenom, amount: "100" }], gas: "200000" };
            
            // const txResponse = await client.signAndBroadcast(userAddress, [msgOrder], fee, "Creando orden en dYdX");

            // --- SIMULACI√ìN DEL √âXITO ---
            orderStatus.textContent = `‚úÖ Orden de ${side} ${size} ${market} a ${price} USD enviada. (Simulado)`;
            console.log('Orden simulada. En un entorno real, la respuesta de la TX ser√≠a:', 'txResponse');
            
        } catch (error) {
            console.error('Error al enviar la orden:', error);
            orderStatus.textContent = `‚ùå Fallo al enviar la orden: ${error.message}`;
        }
    });

</script>
<script>
    // ... (El c√≥digo de conexi√≥n y balances anteriores) ...

    document.getElementById('submitOrderBtn').addEventListener('click', async () => {
        const orderStatus = document.getElementById('orderStatus');
        orderStatus.textContent = 'Procesando orden...';
        
        // 1. Obtener los par√°metros del formulario
        const market = document.getElementById('market').value;
        const side = document.getElementById('side').value; // BUY o SELL
        const size = document.getElementById('size').value;
        const price = document.getElementById('price').value;
        
        if (!size || !price) {
            orderStatus.textContent = '‚ùå Por favor, ingresa el tama√±o y el precio.';
            return;
        }

        try {
            // 2. Obtener la direcci√≥n y el firmador (signer) de Keplr
            const offlineSigner = window.keplr.getOfflineSigner(chainId);
            const accounts = await offlineSigner.getAccounts();
            const userAddress = accounts[0].address;

            // 3. Crear el mensaje de orden (ESTO ES CONCEPTUAL Y DEPENDE DE LA LIBRER√çA)
            // En un proyecto real, se usar√≠a un MessageComposer espec√≠fico de dYdX.
            const msgOrder = {
                typeUrl: "/dydx.exchange.v3.MsgCreateOrder", // Tipo de mensaje espec√≠fico de dYdX
                value: {
                    sender: userAddress,
                    market: market,
                    side: side,
                    size: size,
                    price: price,
                    // Otros par√°metros como expiration, type (LIMIT/MARKET), etc.
                }
            };
            
            // 4. Enviar la transacci√≥n (requiere el objeto SigningStargateClient)
            // const client = await SigningStargateClient.connectWithSigner(rpcEndpoint, offlineSigner);
            
            // const fee = { amount: [{ denom: nativeDenom, amount: "100" }], gas: "200000" };
            
            // const txResponse = await client.signAndBroadcast(userAddress, [msgOrder], fee, "Creando orden en dYdX");

            // --- SIMULACI√ìN DEL √âXITO ---
            orderStatus.textContent = `‚úÖ Orden de ${side} ${size} ${market} a ${price} USD enviada. (Simulado)`;
            console.log('Orden simulada. En un entorno real, la respuesta de la TX ser√≠a:', 'txResponse');
            
        } catch (error) {
            console.error('Error al enviar la orden:', error);
            orderStatus.textContent = `‚ùå Fallo al enviar la orden: ${error.message}`;
        }
    });

</script>

